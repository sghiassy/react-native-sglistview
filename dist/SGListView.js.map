{"version":3,"sources":["../lib/SGListView.js"],"names":[],"mappings":";;;;AAAA;;;;AACA;;AACA;;;;;;;;;;;;;AASA,IAAM,iBAAiB;AACrB,qBADqB,+BACD,QADC,EACS,SADT,EACoB,KADpB,EAC2B,GAD3B,EACgC;AACnD,QAAI,SAAS,SAAT,MAAwB,SAA5B,EAAuC;AACrC,eAAS,SAAT,IAAsB,EAAtB;AACD;;AAED,aAAS,SAAT,EAAoB,KAApB,IAA6B,GAA7B,C;AACD,GAPoB;;;;;;AAYrB,uBAZqB,iCAYC,QAZD,EAYW,WAZX,EAYwB;AAC3C,gBAAY,QAAZ,CAAqB,UAAC,OAAD,EAAa;AAChC,UAAI,YAAY,cAAZ,CAA2B,OAA3B,CAAJ,EAAyC;AAAA;;AACvC,cAAM,iBAAiB,YAAY,OAAZ,CAAvB;;AAEA,yBAAe,QAAf,CAAwB,UAAC,GAAD,EAAS;AAC/B,gBAAI,eAAe,cAAf,CAA8B,GAA9B,CAAJ,EAAwC;;AACtC,kBAAM,cAAc,SAAS,OAAT,EAAkB,GAAlB,CAApB;AACA,kBAAM,wBAAwB,eAAe,GAAf,CAA9B;;;AAGA,kBAAI,eAAe,YAAY,aAA/B,EAA8C;AAC5C,4BAAY,aAAZ,CAA0B,qBAA1B;AACD;AACF;AACF,WAVD;AAHuC;AAcxC;AACF,KAhBD;AAiBD,GA9BoB;;;;;;;AAoCrB,wBApCqB,kCAoCE,KApCF,EAoCS,QApCT,EAoCmB,WApCnB,EAoCgC;AACnD,QAAI,CAAC,MAAM,gBAAX,EAA6B;AAC3B,a;AACD;;AAED,QAAI,CAAC,SAAS,oBAAd,EAAoC;AAClC,eAAS,oBAAT,GAAgC,EAAhC;AACD;;;AAGD,QAAI,wBAAJ;AACA,QAAI,uBAAJ;AACA,QAAI,4BAAJ;AACA,QAAI,2BAAJ;;AAEA,gBAAY,OAAZ,CAAoB,UAAC,OAAD,EAAa;AAC/B,kBAAY,OAAZ,EAAqB,OAArB,CAA6B,UAAC,GAAD,EAAS;AACpC,YAAI,oBAAoB,SAAxB,EAAmC;AACjC,gCAAsB,OAAtB;AACA,4BAAkB,OAAO,GAAP,CAAlB;AACD,SAHD,MAGO;AACL,+BAAqB,OAArB;AACA,2BAAiB,OAAO,GAAP,CAAjB;AACD;;;;;AAKD,YAAM,cAAc,SAAS,OAAT,EAAkB,GAAlB,CAApB;AACA,YAAI,SAAS,oBAAb,EAAmC;AACjC,cAAM,IAAI,SAAS,oBAAT,CAA8B,OAA9B,CAAsC,WAAtC,CAAV;AACA,cAAI,KAAK,CAAT,EAAY;AACV,qBAAS,oBAAT,CAA8B,MAA9B,CAAqC,CAArC,EAAwC,CAAxC;AACD;AACF;AACF,OAnBD;AAoBD,KArBD;;;AAwBA,QAAM,gBAAgB,SAAS,eAAT,GAA2B,eAAjD;AACA,QAAM,kBAAkB,SAAS,cAAT,GAA0B,cAAlD;;AAEA,QAAI,+BAAJ;AACA,QAAI,iBAAiB,SAAS,mBAAT,KAAiC,MAAtD,EAA8D;AAC5D,+BAAyB,IAAzB;AACD,KAFD,MAEO,IAAI,mBAAmB,SAAS,mBAAT,KAAiC,IAAxD,EAA8D;AACnE,+BAAyB,IAAzB;AACD;;;AAGD,QAAI,sBAAJ,EAA4B;AAC1B,UAAI,OAAO,SAAS,oBAAT,CAA8B,GAA9B,EAAX;;AAEA,aAAO,QAAQ,SAAf,EAA0B;AACxB,aAAK,aAAL,CAAmB,KAAnB;AACA,eAAO,SAAS,oBAAT,CAA8B,GAA9B,EAAP;AACD;AACF;;;AAGD,SAAK,IAAI,IAAI,CAAb,EAAgB,KAAK,MAAM,gBAA3B,EAA6C,GAA7C,EAAkD;AAChD,UAAI,cAAJ;;AAEA,UAAI,aAAJ,EAAmB;AACjB,gBAAO,SAAS,mBAAT,EAA8B,kBAAkB,CAAhD,CAAP;AACD,OAFD,MAEO,IAAI,eAAJ,EAAqB;AAC1B,gBAAO,SAAS,kBAAT,EAA6B,iBAAiB,CAA9C,CAAP;AACD;;AAED,UAAI,KAAJ,EAAU;AACR,cAAK,aAAL,CAAmB,IAAnB;AACA,iBAAS,oBAAT,CAA8B,IAA9B,CAAmC,KAAnC;AACD,OAHD,MAGO;AACL;AACD;AACF;;AAED,aAAS,eAAT,GAA2B,eAA3B,C;AACA,aAAS,cAAT,GAA0B,cAA1B,C;;AAEA,QAAI,aAAJ,EAAmB;AACjB,eAAS,mBAAT,GAA+B,IAA/B;AACD,KAFD,MAEO,IAAI,eAAJ,EAAqB;AAC1B,eAAS,mBAAT,GAA+B,MAA/B;AACD;AACF;AAzHoB,CAAvB;;AA6HA,IAAM,aAAa,gBAAM,WAAN,CAAkB;AAAA;;;;;;;AAMnC,0BAEK,sBAAS,SAFd;;;;;;;;;;AAYE,2BAAuB,gBAAM,SAAN,CAAgB,IAZzC;;;;;AAiBE,sBAAkB,iBAAU;AAjB9B,IANmC;;AA0BnC,iBA1BmC,6BA0BjB;AAChB,WAAO;AACL,wBAAkB;AADb,KAAP;AAGD,GA9BkC;;;;;;;AAoCnC,oBApCmC,gCAoCd;;;;AAInB,SAAK,QAAL,GAAgB;AACd,sBAAgB,CADF,EAAhB;AAGD,GA3CkC;;AA6CnC,qBA7CmC,+BA6Cf,WA7Ce,EA6CF,WA7CE,EA6CW;;AAE5C,mBAAe,qBAAf,CAAqC,KAAK,QAA1C,EAAoD,WAApD;;;AAGA,mBAAe,sBAAf,CAAsC,KAAK,KAA3C,EAAkD,KAAK,QAAvD,EAAiE,WAAjE;;;AAGA,QAAI,KAAK,KAAL,CAAW,mBAAf,EAAoC;AAClC,WAAK,KAAL,CAAW,mBAAX,CAA+B,WAA/B,EAA4C,WAA5C;AACD;AACF,GAxDkC;AA0DnC,mBA1DmC,+BA0Df;AAClB,WAAO,KAAK,IAAL,CAAU,cAAjB;AACD,GA5DkC;;;;AA+DnC,oBA/DmC,gCA+Dd;AACnB,WAAO,KAAK,IAAL,CAAU,cAAV,CAAyB,kBAAzB,EAAP;AACD,GAjEkC;;;;;;;AAuEnC,uBAvEmC,iCAuEb,KAvEa,EAuEN;AAC3B,QAAI,kBAAJ;;AAEA,QAAI,MAAM,qBAAV,EAAiC;AAC/B,kBAAY,MAAM,qBAAN,CAA4B,KAA5B,CAAZ;AACD,KAFD,MAEO;AACL,kBACE,uDAAgB,KAAhB,CADF;AAGD;;AAED,WAAO,SAAP;AACD,GAnFkC;AAqFnC,WArFmC,qBAqFzB,OArFyB,EAqFhB,SArFgB,EAqFL,KArFK,EAqFE;AAAA;;;AAEnC,QAAM,OAAO,KAAK,KAAL,CAAW,SAAX,CAAqB,OAArB,EAA8B,SAA9B,EAAyC,KAAzC,CAAb;;;AAGA,WACE;AACE,iBAAW,IADb;AAEE,WAAK,aAAC,GAAD,EAAS;;;AAGZ,uBAAe,mBAAf,CAAmC,MAAK,QAAxC,EAAkD,SAAlD,EAA6D,KAA7D,EAAoE,GAApE;AACD,OANH,GADF;AASD,GAnGkC;AAqGnC,QArGmC,oBAqG1B;AACP,WACE,kEACM,KAAK,KADX;AAEE,WAAI,gBAFN;AAGE,6BAAuB,KAAK,qBAH9B;AAIE,iBAAW,KAAK,SAJlB;AAKE,2BAAqB,KAAK,mBAL5B,IADF;AAQD;AA9GkC,CAAlB,CAAnB;;AAiHA,OAAO,OAAP,GAAiB,UAAjB","file":"SGListView.js","sourcesContent":["import React, { PropTypes } from 'react';\nimport { ListView, ScrollView } from 'react-native';\nimport SGListViewCell from './SGListViewCell';\n\n/**\n * Some methods are stored here. The benefit of doing so are:\n * 1. The methods are truly private from the outside (unliked the _methodName pattern)\n * 2. The methods aren't instantiated with every instance\n * 3. They're static and hold 0 state\n * 4. Keeps the class size smaller\n */\nconst PrivateMethods = {\n  captureReferenceFor(cellData, sectionId, rowId, row) {\n    if (cellData[sectionId] === undefined) {\n      cellData[sectionId] = {};\n    }\n\n    cellData[sectionId][rowId] = row; // Capture the reference\n  },\n\n  /**\n   * Go through the changed rows and update the cell with their new visibility state\n   */\n  updateCellsVisibility(cellData, changedRows) {\n    changedRows.forEvery((section) => {\n      if (changedRows.hasOwnProperty(section)) { // Good JS hygiene check\n        const currentSection = changedRows[section];\n\n        currentSection.forEvery((row) => {\n          if (currentSection.hasOwnProperty(row)) { // Good JS hygiene check\n            const currentCell = cellData[section][row];\n            const currentCellVisibility = currentSection[row];\n\n            // Set the cell's new visibility state\n            if (currentCell && currentCell.setVisibility) {\n              currentCell.setVisibility(currentCellVisibility);\n            }\n          }\n        });\n      }\n    });\n  },\n\n  /**\n   * When the user is scrolling up or down - load the cells in the future to make it\n   * so the user doesn't see any flashing\n   */\n  updateCellsPremptively(props, cellData, visibleRows) {\n    if (!props.premptiveLoading) {\n      return; // No need to run is preemptive loading is 0 or false\n    }\n\n    if (!cellData.premptiveLoadedCells) {\n      cellData.premptiveLoadedCells = [];\n    }\n\n    // Get the first and last visible rows\n    let firstVisibleRow;\n    let lastVisibleRow;\n    let firstVisibleSection;\n    let lastVisibleSection;\n\n    visibleRows.forEach((section) => {\n      visibleRows[section].forEach((row) => {\n        if (firstVisibleRow === undefined) {\n          firstVisibleSection = section;\n          firstVisibleRow = Number(row);\n        } else {\n          lastVisibleSection = section;\n          lastVisibleRow = Number(row);\n        }\n\n        /*\n         * Dont consider a cell preemptiveloaded if it is touched by default visibility logic.\n         */\n        const currentCell = cellData[section][row];\n        if (cellData.premptiveLoadedCells) {\n          const i = cellData.premptiveLoadedCells.indexOf(currentCell);\n          if (i >= 0) {\n            cellData.premptiveLoadedCells.splice(i, 1);\n          }\n        }\n      });\n    });\n\n    // Figure out if we're scrolling up or down\n    const isScrollingUp = cellData.firstVisibleRow > firstVisibleRow;\n    const isScrollingDown = cellData.lastVisibleRow < lastVisibleRow;\n\n    let scrollDirectionChanged;\n    if (isScrollingUp && cellData.lastScrollDirection === 'down') {\n      scrollDirectionChanged = true;\n    } else if (isScrollingDown && cellData.lastScrollDirection === 'up') {\n      scrollDirectionChanged = true;\n    }\n\n    // remove the other side's preemptive cells\n    if (scrollDirectionChanged) {\n      let cell = cellData.premptiveLoadedCells.pop();\n\n      while (cell != undefined) {\n        cell.setVisibility(false);\n        cell = cellData.premptiveLoadedCells.pop();\n      }\n    }\n\n    // Preemptively set cells\n    for (let i = 1; i <= props.premptiveLoading; i++) {\n      let cell;\n\n      if (isScrollingUp) {\n        cell = cellData[firstVisibleSection][firstVisibleRow - i];\n      } else if (isScrollingDown) {\n        cell = cellData[lastVisibleSection][lastVisibleRow + i];\n      }\n\n      if (cell) {\n        cell.setVisibility(true);\n        cellData.premptiveLoadedCells.push(cell);\n      } else {\n        break;\n      }\n    }\n\n    cellData.firstVisibleRow = firstVisibleRow; // cache the first seen row\n    cellData.lastVisibleRow = lastVisibleRow; // cache the last seen row\n\n    if (isScrollingUp) {\n      cellData.lastScrollDirection = 'up';\n    } else if (isScrollingDown) {\n      cellData.lastScrollDirection = 'down';\n    }\n  },\n};\n\n\nconst SGListView = React.createClass({\n\n  /**\n   * Object Lifecycle Methods\n   */\n\n  propTypes: {\n    // Default the propTypes to those as specified by ListView\n    ...ListView.propTypes,\n\n    /**\n     * OVERRIDE LISTVIEW's DEFAULT VALUE: Made component not required, since SGListView will provide one by default\n     *\n     * (props) => renderable\n     *\n     * A function that returns the scrollable component in which the list rows\n     * are rendered. Defaults to returning a ScrollView with the given props.\n     */\n    renderScrollComponent: React.PropTypes.func,\n\n    /**\n     * Number of cells to preeptively render in front of the users scrolling\n     */\n    premptiveLoading: PropTypes.number,\n  },\n\n  getDefaultProps() {\n    return {\n      premptiveLoading: 2,\n    };\n  },\n\n  /**\n   * View Lifecycle Methods\n   */\n\n  componentWillMount() {\n    // This object keeps track of the cell data.\n    // NOTE: We don't want to trigger a render pass when updating the data here\n    //       so we don't store this information in this.state.\n    this.cellData = {\n      lastVisibleRow: 0, // keep track of the last row rendered\n    };\n  },\n\n  onChangeVisibleRows(visibleRows, changedRows) {\n    // Update cell visibibility per the changedRows\n    PrivateMethods.updateCellsVisibility(this.cellData, changedRows);\n\n    // Premepty show rows to avoid onscreen flashes\n    PrivateMethods.updateCellsPremptively(this.props, this.cellData, visibleRows);\n\n    // If the user supplied an onChangeVisibleRows function, then call it\n    if (this.props.onChangeVisibleRows) {\n      this.props.onChangeVisibleRows(visibleRows, changedRows);\n    }\n  },\n\n  getNativeListView() {\n    return this.refs.nativeListView;\n  },\n\n  // https://github.com/sghiassy/react-native-sglistview/issues/14\n  getScrollResponder() {\n    return this.refs.nativeListView.getScrollResponder();\n  },\n\n  /**\n   * Render Methods\n   */\n\n  renderScrollComponent(props) {\n    let component;\n\n    if (props.renderScrollComponent) {\n      component = props.renderScrollComponent(props);\n    } else {\n      component = (\n        <ScrollView {...props} />\n      );\n    }\n\n    return component;\n  },\n\n  renderRow(rowData, sectionID, rowID) {\n    // Get the user's view\n    const view = this.props.renderRow(rowData, sectionID, rowID);\n\n    // Wrap the user's view in a SGListViewCell for tracking & performance\n    return (\n      <SGListViewCell\n        usersView={view}\n        ref={(row) => {\n          // Capture a reference to the cell on creation\n          // We have to do it this way for ListView: https://github.com/facebook/react-native/issues/897\n          PrivateMethods.captureReferenceFor(this.cellData, sectionID, rowID, row);\n        }} />\n    );\n  },\n\n  render() {\n    return (\n      <ListView\n        {...this.props}\n        ref=\"nativeListView\"\n        renderScrollComponent={this.renderScrollComponent}\n        renderRow={this.renderRow}\n        onChangeVisibleRows={this.onChangeVisibleRows} />\n    );\n  },\n});\n\nmodule.exports = SGListView;\n"]}