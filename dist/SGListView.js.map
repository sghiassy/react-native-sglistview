{"version":3,"sources":["../lib/SGListView.js"],"names":["PrivateMethods","captureReferenceFor","cellData","sectionId","rowId","row","undefined","updateCellsVisibility","visibleRows","changedRows","section","hasOwnProperty","currentSection","currentCell","currentCellVisibility","setVisibility","updateCellsPremptively","props","premptiveLoading","premptiveLoadedCells","firstVisibleRow","lastVisibleRow","firstVisibleSection","lastVisibleSection","Number","i","indexOf","splice","isScrollingUp","isScrollingDown","scrollDirectionChanged","lastScrollDirection","cell","pop","push","SGListView","createClass","propTypes","renderScrollComponent","PropTypes","func","number","getDefaultProps","componentWillMount","onChangeVisibleRows","getNativeListView","refs","nativeListView","getScrollResponder","component","renderRow","rowData","sectionID","rowID","view","render","module","exports"],"mappings":"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","file":"SGListView.js","sourcesContent":["import React, { PropTypes } from 'react';\nimport { ListView, ScrollView } from 'react-native';\nimport SGListViewCell from './SGListViewCell';\n\n/**\n * Some methods are stored here. The benefit of doing so are:\n * 1. The methods are truly private from the outside (unliked the _methodName pattern)\n * 2. The methods aren't instantiated with every instance\n * 3. They're static and hold 0 state\n * 4. Keeps the class size smaller\n */\nconst PrivateMethods = {\n  captureReferenceFor(cellData, sectionId, rowId, row) {\n    if (cellData[sectionId] === undefined) {\n      cellData[sectionId] = {};\n    }\n\n    cellData[sectionId][rowId] = row; // Capture the reference\n  },\n\n  /**\n   * Go through the changed rows and update the cell with their new visibility state\n   */\n  updateCellsVisibility(cellData, visibleRows, changedRows) {\n    // update changed rows\n    for (const section in changedRows) {\n      if (changedRows.hasOwnProperty(section)) { // Good JS hygiene check\n        const currentSection = changedRows[section];\n\n        for (const row in currentSection) {\n          if (currentSection.hasOwnProperty(row)) { // Good JS hygiene check\n            const currentCell = cellData[section][row];\n            const currentCellVisibility = currentSection[row];\n\n            // Set the cell's new visibility state\n            if (currentCell && currentCell.setVisibility) {\n              currentCell.setVisibility(currentCellVisibility);\n            }\n          }\n        }\n      }\n    }\n\n    // set visible rows visible, see https://github.com/sghiassy/react-native-sglistview/issues/12\n    for (const section in visibleRows) {\n      if (visibleRows.hasOwnProperty(section)) { // Good JS hygiene check\n        const currentSection = visibleRows[section];\n\n        for (const row in currentSection) {\n          if (currentSection.hasOwnProperty(row)) { // Good JS hygiene check\n            const currentCell = cellData[section][row];\n\n            // Set the cell visible\n            if (currentCell && currentCell.setVisibility) {\n              currentCell.setVisibility(true);\n            }\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * When the user is scrolling up or down - load the cells in the future to make it\n   * so the user doesn't see any flashing\n   */\n  updateCellsPremptively(props, cellData, visibleRows) {\n    if (!props.premptiveLoading) {\n      return; // No need to run is preemptive loading is 0 or false\n    }\n\n    if (!cellData.premptiveLoadedCells) {\n      cellData.premptiveLoadedCells = [];\n    }\n\n    // Get the first and last visible rows\n    let firstVisibleRow;\n    let lastVisibleRow;\n    let firstVisibleSection;\n    let lastVisibleSection;\n\n    for (const section in visibleRows) {\n      if (visibleRows.hasOwnProperty(section)) { // Good JS hygiene check\n        for (const row in visibleRows[section]) {\n          if (firstVisibleRow === undefined) {\n            firstVisibleSection = section;\n            firstVisibleRow = Number(row);\n          } else {\n            lastVisibleSection = section;\n            lastVisibleRow = Number(row);\n          }\n\n          /*\n           * Dont consider a cell preemptiveloaded if it is touched by default visibility logic.\n           */\n          const currentCell = cellData[section][row];\n          if (cellData.premptiveLoadedCells) {\n            const i = cellData.premptiveLoadedCells.indexOf(currentCell);\n            if (i >= 0) {\n              cellData.premptiveLoadedCells.splice(i, 1);\n            }\n          }\n        }\n      }\n    }\n\n    // Figure out if we're scrolling up or down\n    const isScrollingUp = cellData.firstVisibleRow > firstVisibleRow;\n    const isScrollingDown = cellData.lastVisibleRow < lastVisibleRow;\n\n    let scrollDirectionChanged;\n    if (isScrollingUp && cellData.lastScrollDirection === 'down') {\n      scrollDirectionChanged = true;\n    } else if (isScrollingDown && cellData.lastScrollDirection === 'up') {\n      scrollDirectionChanged = true;\n    }\n\n    // remove the other side's preemptive cells\n    if (scrollDirectionChanged) {\n      let cell = cellData.premptiveLoadedCells.pop();\n\n      while (cell != undefined) {\n        cell.setVisibility(false);\n        cell = cellData.premptiveLoadedCells.pop();\n      }\n    }\n\n    // Preemptively set cells\n    for (let i = 1; i <= props.premptiveLoading; i++) {\n      let cell;\n\n      if (isScrollingUp) {\n        cell = cellData[firstVisibleSection][firstVisibleRow - i];\n      } else if (isScrollingDown) {\n        cell = cellData[lastVisibleSection][lastVisibleRow + i];\n      }\n\n      if (cell) {\n        cell.setVisibility(true);\n        cellData.premptiveLoadedCells.push(cell);\n      } else {\n        break;\n      }\n    }\n\n    cellData.firstVisibleRow = firstVisibleRow; // cache the first seen row\n    cellData.lastVisibleRow = lastVisibleRow; // cache the last seen row\n\n    if (isScrollingUp) {\n      cellData.lastScrollDirection = 'up';\n    } else if (isScrollingDown) {\n      cellData.lastScrollDirection = 'down';\n    }\n  },\n};\n\n\nconst SGListView = React.createClass({\n\n  /**\n   * Object Lifecycle Methods\n   */\n\n  propTypes: {\n    // Default the propTypes to those as specified by ListView\n    ...ListView.propTypes,\n\n    /**\n     * OVERRIDE LISTVIEW's DEFAULT VALUE: Made component not required, since SGListView will provide one by default\n     *\n     * (props) => renderable\n     *\n     * A function that returns the scrollable component in which the list rows\n     * are rendered. Defaults to returning a ScrollView with the given props.\n     */\n    renderScrollComponent: React.PropTypes.func,\n\n    /**\n     * Number of cells to preeptively render in front of the users scrolling\n     */\n    premptiveLoading: PropTypes.number,\n  },\n\n  getDefaultProps() {\n    return {\n      premptiveLoading: 2,\n    };\n  },\n\n  /**\n   * View Lifecycle Methods\n   */\n\n  componentWillMount() {\n    // This object keeps track of the cell data.\n    // NOTE: We don't want to trigger a render pass when updating the data here\n    //       so we don't store this information in this.state.\n    this.cellData = {\n      lastVisibleRow: 0, // keep track of the last row rendered\n    };\n  },\n\n  onChangeVisibleRows(visibleRows, changedRows) {\n    // Update cell visibibility per the changedRows\n    PrivateMethods.updateCellsVisibility(this.cellData, visibleRows, changedRows);\n\n    // Premepty show rows to avoid onscreen flashes\n    PrivateMethods.updateCellsPremptively(this.props, this.cellData, visibleRows);\n\n    // If the user supplied an onChangeVisibleRows function, then call it\n    if (this.props.onChangeVisibleRows) {\n      this.props.onChangeVisibleRows(visibleRows, changedRows);\n    }\n  },\n\n  getNativeListView() {\n    return this.refs.nativeListView;\n  },\n\n  // https://github.com/sghiassy/react-native-sglistview/issues/14\n  getScrollResponder() {\n    return this.refs.nativeListView.getScrollResponder();\n  },\n\n  /**\n   * Render Methods\n   */\n\n  renderScrollComponent(props) {\n    let component;\n\n    if (props.renderScrollComponent) {\n      component = props.renderScrollComponent(props);\n    } else {\n      component = (\n        <ScrollView {...props} />\n      );\n    }\n\n    return component;\n  },\n\n  renderRow(rowData, sectionID, rowID) {\n    // Get the user's view\n    const view = this.props.renderRow(rowData, sectionID, rowID);\n\n    // Wrap the user's view in a SGListViewCell for tracking & performance\n    return (\n      <SGListViewCell\n        usersView={view}\n        ref={(row) => {\n          // Capture a reference to the cell on creation\n          // We have to do it this way for ListView: https://github.com/facebook/react-native/issues/897\n          PrivateMethods.captureReferenceFor(this.cellData, sectionID, rowID, row);\n        }} />\n    );\n  },\n\n  render() {\n    return (\n      <ListView\n        {...this.props}\n        ref=\"nativeListView\"\n        renderScrollComponent={this.renderScrollComponent}\n        renderRow={this.renderRow}\n        onChangeVisibleRows={this.onChangeVisibleRows} />\n    );\n  },\n});\n\nmodule.exports = SGListView;\n"]}